- SASS
    - special type of css file that has additional features to make writing css for large scale app easier
    - browser dont understand sass, need to convert to css file
    - need to convert sass file to css file (done by module bundler like Parcel) else css wont apply

=====================================================================================
Project Guidelines
=====================================================================================

  -------------------------------------------------------------------------------------------------------------------
  Project Setup:
  -------------------------------------------------------------------------------------------------------------------
    1) npm init within project directory
    2) go to package.json -> modify "main" from index.js to <desired file name>.js
    3) set up npm scripts
      - "start": "parcel index.html",
      - "build": "parcel build index.html"
    4) npm i parcel@2 (install v2 of parcel into project dir)
    5) npm i (within project dir to install all dependencies)
    6) add node_modules, dist, .parcel-cache into .gitignore

  -------------------------------------------------------------------------------------------------------------------
  Implementation 1: Load Recipe from API (https://forkify-api.herokuapp.com/v2)
  -------------------------------------------------------------------------------------------------------------------
    1) go to controller.js, create async function to fetch data
      - async showRecipe()
    
  Implementation 2: Render loaded recipe to view
    1) Retrieve html from index.html (have to create own if new project)
      - class="recipe__fig"
    2) include it together in the showRecipe() method created above
      - (dont reference this, will break into MVC architecture later on)
    3) replace html template string with the appropriate variable storing info from the API
      - create for loop to loop through ingredient data to render onto html
        - using .map() since .map returns array then use .join to combine all into string
    4) insert html to DOM using parent element (event propagation)
      - get rid of old markup then insert new markup
      - recipeContainer.innerHTML = ''; // remove existing content
      - recipeContainer.insertAdjacentHTML('afterbegin', markup);
    5) change icon src in .js file
      - when using parcel, static files are moved to "dist" dir with new unique name
        - import myIcons from 'url:../img/icons.svg';
          - myIcons will be the path to the static resource in "dist" dir
        - import <desiredName> from 'url:<pathToStaticResourceInDevDir>'
          - 'url:' syntax required from parcel 2 onwards for any static resources
          - <desiredName> can be any variable name of choice
    6) replace original "src/img/icons.svg" with ${myIcons}
      - since myIcons is the variable containing the path to the static resource in the "dist" dir
  
  -------------------------------------------------------------------------------------------------------------------
  Implementation 3: Add loading spinner
  -------------------------------------------------------------------------------------------------------------------
    1) copy spinner html to controller.js
    2) implement renderSpinner method (takes in parentElement as argument for reusability) 
      - refer to css -> .spinner class to see how spinner syntax are made
    3) call renderSpinner method inside showRecipe method
  
  Implement polyfill for project
    - old browsers can support app
    - npm i core-js regenerator-runtime
  import 'core-js/stable';
  import 'regenerator-runtime/runtime'

  -------------------------------------------------------------------------------------------------------------------
  Implementation 4: Add Event Listeners for:
  -------------------------------------------------------------------------------------------------------------------
    - When user selects recipe (from search results)
    - When page loads with recipe ID (from URL)
    * listen to hash change from url, then fetch data upon hash change detected

  1) window.addEventListener('hashchange', showRecipe); in controller.js
  2) go to showRecipe method & add logic to retrieve hash from url
    - const id = window.location.hash.slice(1); // add inside showRecipe function
  3) window.addEventListener('load', showRecipe); // for new page load
  4) refactor code:
    ['hashchange', 'load'].forEach(evt => window.addEventListener(evt, showRecipe));
  5) add guard clause for if no recipe hash exist in url
    - if (!id) return; // guard clause if no id
  
  -------------------------------------------------------------------------------------------------------------------
  Implementation 5: Refactoring for MVC Architecture
  -------------------------------------------------------------------------------------------------------------------
    1) create model.js & "view" dir + recipeView.js inside "view" dir
    2) go to model.js & create state obj (used to store all data)
    3) create "loadRecipe" function within model.js
      - transfer some code from controller.js for loading recipe into loadRecipe function
        - controller will get hash then pass it as argument to model for Recipe loading
        - update data storage from recipe to state.recipe
    4) import * as model from './model'; in controller.js 
    5) call loadRecipe function within showRecipe function in controller.js to update state
      - await model.loadRecipe(id);
      - update markup from recipe.image -> model.state.recipe.image
    6) set up RecipeView class in recipeView.js
    7) export instance of RecipeView (instead of RecipeView class itself to prevent instantiation of more than 1 view obj)
      - export default new RecipeView(); within RecipeView.js
    8) import recipeView from './views/recipeView.js'; in controller.js
      * in order to pass data to View, create a public method within View class that accepts in required data in argument
        - "render()" method is commonly used, esp in React, to pass in data to View class
    9) create render(data) method inside RecipeView class
      - this.#data = data; // render method acts like a setter method to pass data from controller to view
    10) create private method #generateMarkup() {} where it will return the required markup string
      - transfer markup string from controller.js to generateMarkup function
      - replace model.state.recipe -> this.#data. 
    11) call recipeView.render(model.state.recipe); inside controller.js
    12) create private method #clear() within RecipeView.js to clear existing html content before injecting markup
    13) call this.#generateMarkup method within render() method + this.#clear + inject HTML 
    14) import icons from 'url:../../img/icons.svg'; inside RecipeView.js, need to check path is correct
    15) rename showRecipe to controlRecipe in controller.js
    16) move renderSpinner function from controller.js to RecipeView.js as public method
  
  -------------------------------------------------------------------------------------------------------------------
  Implementation 6: Use fractional module to divide numbers into fractions for better showing of ingredient servings
  -------------------------------------------------------------------------------------------------------------------
    1) npm i fractional
    2) import {Fraction} from 'fractional' inside recipeView.js
    3) go to template string for recipe__ingredient-list -> new Fraction(ing.quantity).toString()
  
  -------------------------------------------------------------------------------------------------------------------
  Implementation 7: Creating helper.js & config.js
  -------------------------------------------------------------------------------------------------------------------
    - for ease of configuring / modifying common files / logic used across app

    1) create config.js & helper.js in "src/js" dir
      - config.js : constants & common variables used in project
      - helper.js : for common logic / functions used in project
    2) create export const API_URL in config.js & transfer the API url from model.js to config.js
    3) import {API_URL} from './config.js' in model.js
    4) update template string for the API URL to fetch const res = await fetch(`${API_URL}/${id}`);
    5) create & export getJSON() function in helper.js
      - used to fetch required data from external APIs using fetch API
      - transfer some code from model.js loadRecipe function to helper.js getJSON function
      - implement try catch in getJSON & throw err in catch so that model.js can handle the error thrown as alert
    6) go to model.js & import {getJSON} from helper.js
    7) call getJSON in model.js -> const data = await getJSON(`${API_URL}/${id}`);
    8) implement timeout function in helper.js to timeout api call after some time to prevent app hang
    9) create a promise race between timeout fn & getJSON fn to return whichever promise resolve first
      - const res = await Promise.race([fetch(`${url}`), timeout(5)]); // race between fetch & timeout 5 seconds
    10) create export const TIMEOUT_SECONDS = 10; in config.js
      - import { TIMEOUT_SECONDS } from "./config"; inside helper.js & implement in timeout(TIMEOUT_SECONDS)
